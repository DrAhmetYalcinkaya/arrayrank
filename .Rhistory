warning("The resulting data frame is empty after processing.")
}
# No need to replace dots in column names
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction2(raw_data, array_type = "chambered", format = "wide")
View(wide_df2)
View(wide_df)
View(wide_df2)
extraction2 <- function(data, array_type, format = "wide") {
# Load necessary packages
library(dplyr)
library(tidyr)
proteins <- data$genes
files <- data$targets
values <- data$R
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
df$original_order <- seq_len(nrow(df))  # Add index to preserve order
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
df <- df_out
if (format == "long" & array_type != "huprot") {
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
# Arrange by original order
name_order <- proteins %>%
mutate(original_order = seq_len(nrow(.))) %>%
select(Name, original_order) %>%
distinct()
long_result <- long_result %>%
left_join(name_order, by = "Name") %>%
arrange(original_order) %>%
select(-original_order)
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
# Arrange by original order
name_order <- proteins %>%
mutate(original_order = seq_len(nrow(.))) %>%
select(Name, original_order) %>%
distinct()
long_result <- long_result %>%
left_join(name_order, by = "Name") %>%
arrange(original_order) %>%
select(-original_order)
output <- long_result
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "wide") {
# Define required columns based on array type
required_columns <- if (array_type %in% c("chambered", "segmented")) {
c("array", "Block", "Name", "value")
} else {
c("array", "Name", "value")
}
# Check if the data contains the required columns
if (!all(required_columns %in% colnames(df))) {
stop(paste("Data must contain the following columns:", paste(required_columns, collapse = ", ")))
}
if (array_type %in% c("chambered", "segmented")) {
# Zero-pad block numbers
df <- df %>%
mutate(Block = sprintf("%02d", as.numeric(Block)))
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
# Generate consistent column names
long_result <- long_result %>%
mutate(array = paste0("Arr", gsub("[^0-9]", "", basename(array))),
Array_Block = paste0(array, "Block", Block))
# Pivot wider
wide_result <- long_result %>%
select(Name, Array_Block, Mvalue) %>%
pivot_wider(names_from = Array_Block, values_from = Mvalue)
# Arrange by original order
name_order <- proteins %>%
mutate(original_order = seq_len(nrow(.))) %>%
select(Name, original_order) %>%
distinct()
wide_result <- name_order %>%
left_join(wide_result, by = "Name") %>%
arrange(original_order) %>%
select(-original_order)
output <- wide_result
message("Data calculated/arranged for chambered/segmented arrays")
} else if (array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
# Generate consistent array names
long_result <- long_result %>%
mutate(array = paste0("Arr", gsub("[^0-9]", "", basename(array))))
# Pivot wider
wide_result <- long_result %>%
select(Name, array, Mvalue) %>%
pivot_wider(names_from = array, values_from = Mvalue)
# Arrange by original order
name_order <- proteins %>%
mutate(original_order = seq_len(nrow(.))) %>%
select(Name, original_order) %>%
distinct()
wide_result <- name_order %>%
left_join(wide_result, by = "Name") %>%
arrange(original_order) %>%
select(-original_order)
output <- wide_result
message("Data calculated/arranged for huprot arrays")
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(output) == 0) {
warning("The resulting data frame is empty after processing.")
}
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction2(raw_data, array_type = "chambered", format = "wide")
View(wide_df2)
extraction2 <- function(data, array_type, format = "wide") {
# Load necessary packages
library(dplyr)
library(tidyr)
proteins <- data$genes
files <- data$targets
values <- data$R
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
# Use data frame directly without converting to data.table
df <- df_out
if (format == "long" & array_type != "huprot") {
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
output <- long_result
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "wide") {
# Define required columns based on array type
required_columns <- if (array_type %in% c("chambered", "segmented")) {
c("array", "Block", "Name", "value")
} else {
c("array", "Name", "value")
}
# Check if the data contains the required columns
if (!all(required_columns %in% colnames(df))) {
stop(paste("Data must contain the following columns:", paste(required_columns, collapse = ", ")))
}
if (array_type %in% c("chambered", "segmented")) {
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
wide_result <- long_result %>%
pivot_wider(names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
# Transpose the data frame
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2, ])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
# Convert data to numeric and round
numeric_df <- corrected_transposed_result %>%
mutate(across(everything(), ~ as.numeric(.))) %>%
mutate(across(everything(), ~ round(., 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
wide_result <- long_result %>%
pivot_wider(names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- transposed_result[-1, ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- corrected_transposed_result %>%
mutate(across(everything(), ~ as.numeric(.))) %>%
mutate(across(everything(), ~ round(., 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
# Replace dots with zeros in column names
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction2(raw_data, array_type = "chambered", format = "wide")
extraction2 <- function(data, array_type, format = "wide") {
# Load necessary packages
library(dplyr)
library(tidyr)
proteins <- data$genes
files <- data$targets
values <- data$R
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
# Use data frame directly without converting to data.table
df <- df_out
df <- df %>%
mutate(Block = sprintf("%02d", as.numeric(Block)))
if (format == "long" & array_type != "huprot") {
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
output <- long_result
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "wide") {
# Define required columns based on array type
required_columns <- if (array_type %in% c("chambered", "segmented")) {
c("array", "Block", "Name", "value")
} else {
c("array", "Name", "value")
}
# Check if the data contains the required columns
if (!all(required_columns %in% colnames(df))) {
stop(paste("Data must contain the following columns:", paste(required_columns, collapse = ", ")))
}
if (array_type %in% c("chambered", "segmented")) {
long_result <- df %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
wide_result <- long_result %>%
pivot_wider(names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
# Transpose the data frame
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2, ])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
# Convert data to numeric and round
numeric_df <- corrected_transposed_result %>%
mutate(across(everything(), ~ as.numeric(.))) %>%
mutate(across(everything(), ~ round(., 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df %>%
group_by(array, Name) %>%
summarise(Mvalue = mean(value, na.rm = TRUE), .groups = 'drop')
wide_result <- long_result %>%
pivot_wider(names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- transposed_result[-1, ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- corrected_transposed_result %>%
mutate(across(everything(), ~ as.numeric(.))) %>%
mutate(across(everything(), ~ round(., 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
# Replace dots with zeros in column names
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction2(raw_data, array_type = "chambered", format = "wide")
wide_df2 <- extraction2(raw_data, array_type = "chambered", format = "long")
View(wide_df2)
# 1b. identify discordant duplicates in data (to cross-check with ultimate output)
discordants <- discordant(raw_data, fold = 1.5, abs = 1000)
library(roxygen2)
library(devtools)
roxygenize()
remove.packages("arrayrank")
detach("package:arrayrank", unload = TRUE)
library(devtools)
devtools::install_github("DrAhmetYalcinkaya/arrayrank")
library(arrayrank)
# 4. read data from backup file
q_data <- readxl::read_xlsx(choose.files())
View(q_data)
# 6. detect proteins with hits and rank them (in this example: the groups, BD and SSc, have been provided as a vector)
q_result <- detect.hits(q_data, controls = "BD", examine = "SSc", sdmean = 0.7,
fold_threshold = 10, absolute_threshold = 8000)
View(q_result)
# 6. detect proteins with hits and rank them (in this example: the groups, BD and SSc, have been provided as a vector)
q_result <- detect.hits(q_data, controls = "BD", examine = "SSc", sdmean = 0.9,
fold_threshold = 20, absolute_threshold = 10000)
View(q_result)
# 6. detect proteins with hits and rank them (in this example: the groups, BD and SSc, have been provided as a vector)
q_result <- detect.hits(q_data, controls = "BD", examine = "SSc", sdmean = 0.8,
fold_threshold = 15, absolute_threshold = 9000)
View(q_result)
#' @import writexl
#' @import readxl
#' @importFrom stats median runif sd
#' @importFrom utils choose.dir
#'
#' @examples
#' \dontrun{
#' # Run the function to select a directory and read .gpr files
#' raw_data <- read.gpr()
#' }
read.gpr <- function(fdata = "mean", bgcorrect = T) {
if (.Platform$OS.type == "windows") {
directory <- choose.dir()
} else {
directory <- tk_choose.dir()
}
if (is.na(directory) || directory == "") {
return(NULL)
}
files <- list.files(path = directory, pattern = "*.gpr", full.names = T, include.dirs = F)
if (length(files) == 0) {
message("No .gpr files found in the selected directory.")
return(NULL)
}
if(fdata == "mean"){
raw_data <- limma::read.maimages(files, source = "genepix")
raw_data$targets$FileName <- basename(raw_data$targets$FileName)
} else {
raw_data <- limma::read.maimages(files, source = "genepix.median")
raw_data$targets$FileName <- basename(raw_data$targets$FileName)
}
elements <- c("R", "G", "Rb", "Gb")
if (all(elements %in% names(raw_data)) & bgcorrect == T) {
message("Red, Green channels and background data found to exist, user requested bg correction; subtracting background.")
post_bg <- limma::backgroundCorrect(raw_data, method = "subtract")
} else {
message("No background subtration performed.")
post_bg <- raw_data
}
return(post_bg)
}
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T)
# 1. collect gpr data and make dataset
raw_data2 <- read.gpr(bgcorrect = T, fdata = "median")
library(arrayrank)
wide_df <- extraction(raw_data, array_type = "chambered", format = "wide")
wide_df2 <- extraction(raw_data, array_type = "chambered", format = "wide")
View(wide_df)
View(wide_df2)
View(wide_df)
View(wide_df2)
View(wide_df)
wide_df2 <- extraction(raw_data2, array_type = "chambered", format = "wide")
View(wide_df2)
View(wide_df)
View(wide_df2)
View(wide_df2)
View(wide_df)
library(roxygen2)
library(devtools)
roxygenize()
build()
roxygenize()
build()
check()
remove.packages("arrayrank")
detach("package:arrayrank", unload = TRUE)
library(devtools)
devtools::install_github("DrAhmetYalcinkaya/arrayrank")
library(arrayrank)
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
wide_df <- extraction(raw_data, array_type = "chambered", format = "wide")
View(wide_df)
# 1b. identify discordant duplicates in data (to cross-check with ultimate output)
discordants <- discordant(raw_data, fold = 1.5, abs = 1000)
# 2. data correction
corr_df <- replace.low(wide_df, offset = 10)
qnorm_df <- multinorm(corr_df, method= "protein", protein = 447)
View(qnorm_df)
which(max(qnorm_df))
which(qnorm_df == max(qnorm_df))
which(qnorm_df == max(qnorm_df), arr.ind = T)
multinorm <- function(data, method = "quantile", protein = NULL){
data <- as.data.frame(data)
data[] <- lapply(data, as.numeric)
original_col_order <- colnames(data)
if (ncol(data) == 0 || nrow(data) == 0) {
stop("Data contains no valid numeric columns or rows.")
}
subject_medians <- apply(data, 2, median)
overall_median <- median(unlist(data))
lows <- apply(data, 2, function(x) x < overall_median)
n_lows <- colSums(lows)
cut_lows <- which(n_lows > (0.8 * nrow(data)))
excluded_columns <- NULL
if (length(cut_lows) > 0) {
excluded_columns <- data[, cut_lows, drop = FALSE]
message("It appears that ", paste(colnames(data)[cut_lows], collapse = ", "),
" is/are negative controls (non-sample).\nHighly suggested to exclude these indices from normalization.")
response <- readline(prompt = "Would you like to exclude these indices from normalization? Enter 'yes' or 'no': ")
if (tolower(response) == "yes") {
data <- data[, -cut_lows, drop = FALSE]
message("Excluded the identified negative control columns from normalization.")
} else {
excluded_columns <- NULL
message("Proceeding without excluding any columns.")
}
} else {
message("No columns identified as negative controls. Proceeding with normalization.")
}
if(method == "quantile"){
output <- as.data.frame(limma::normalizeQuantiles(data))
message("Normalized each column (observations) with limma-Quantile.")
} else if(method == "arrays"){
output <- as.data.frame(limma::normalizeBetweenArrays(data))
message("Normalized between arrays (Blocks or Huprot) with limma-BetweenArrays.")
} else if(method == "protein"){
if(is.null(protein) || protein > nrow(data) || protein <= 0){
stop("Please provide a valid row index for the protein parameter. Should range from 1 to ", nrow(data), " (the latter is protein count)")
}
protein_mean <- mean(as.numeric(data[protein,]))
mean_sample_ratio <- (protein_mean / data[protein,])
output <- sweep(data, 2, as.numeric(mean_sample_ratio), `*`)
message(paste("Normalized according to", rownames(data)[protein], "values."))
message(paste("NOTES: Max value in input data was:", max(data), "\nMax value in output data is:", round(max(output),2),
"\nMax values greater than 2-3 fold of 65000 may cause overestimation in hit detection.",
"\nIn such a case, please consider quantile or between-arrays normalization instead of protein-based normalization."))
} else {
stop("Please define normalization parameters correctly.")
}
if (!is.null(excluded_columns)) {
output <- cbind(output, excluded_columns)
output <- output[, original_col_order]
}
return(output)
}
qnorm_df <- multinorm(corr_df, method= "protein", protein = 447)
which(qnorm_df == max(qnorm_df), arr.ind = T)
View(corr_df)
qnorm_df <- multinorm(corr_df, method= "protein", protein = 267)
which(qnorm_df == max(qnorm_df), arr.ind = T)
qnorm_df <- multinorm(corr_df, method= "protein", protein = 297)
which(qnorm_df == max(qnorm_df), arr.ind = T)
matching_rows <- rownames(corr_df)[grepl("igg|igm", rownames(corr_df), ignore.case = TRUE)]
matching_rows
normalizing_indices <- rownames(corr_df)[grepl("igg|igm", rownames(corr_df), ignore.case = TRUE)]
normalizing_indices <- which(rownames(corr_df)[grepl("igg|igm", rownames(corr_df), ignore.case = TRUE)])
normalizing_indices <- which(grepl("igg|igm", rownames(corr_df), ignore.case = TRUE))
normalizing_indices
selected <- corr_df[normalizing_indices,]
View(selected)
