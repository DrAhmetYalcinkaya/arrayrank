}
if (format == "long" & array_type != "huprot") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
output <- long_result
} else if (format == "wide") {
if (array_type == "chambered" || array_type == "segmented") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2,])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays. Duplicate protein names appended with .n --creating dataframe...")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- as.data.frame(transposed_result[-1, ])
colnames(corrected_transposed_result) <- new_colname
row_names <- rownames(transposed_result)
row_names <- row_names[-1]
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- row_names
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
library(arrayrank)
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
View(raw_data)
#' \dontrun{
#' # Assuming 'raw_data' is an RGList object obtained from read.gpr()
#' Meaning run read.gpr first!
#'
#' # Extract data in long format for chambered arrays
#' long_data <- extraction(data = raw_data, array_type = "chambered", format = "long")
#'
#' # Extract data in wide format for huprot arrays
#' wide_data <- extraction(data = raw_data, array_type = "huprot", format = "wide")
#' }
extraction <- function(data, array_type, format = "wide") {
proteins <- data$genes
files <- data$targets
values <- data$R
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
if (format == "long" & array_type != "huprot") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
output <- long_result
} else if (format == "wide") {
if (array_type == "chambered" || array_type == "segmented") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2,])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays. Duplicate protein names appended with .n --creating dataframe...")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- as.data.frame(transposed_result[-1, ])
colnames(corrected_transposed_result) <- new_colname
row_names <- rownames(transposed_result)
row_names <- row_names[-1]
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- row_names
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
library(tidyverse)
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
View(wide_df)
#' \dontrun{
#' # Assuming 'raw_data' is an RGList object obtained from read.gpr()
#' Meaning run read.gpr first!
#'
#' # Extract data in long format for chambered arrays
#' long_data <- extraction(data = raw_data, array_type = "chambered", format = "long")
#'
#' # Extract data in wide format for huprot arrays
#' wide_data <- extraction(data = raw_data, array_type = "huprot", format = "wide")
#' }
extraction <- function(data, array_type, format = "wide", channel = "R") {
proteins <- data$genes
files <- data$targets
values <- data$channel
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
if (format == "long" & array_type != "huprot") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
output <- long_result
} else if (format == "wide") {
if (array_type == "chambered" || array_type == "segmented") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2,])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays. Duplicate protein names appended with .n --creating dataframe...")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- as.data.frame(transposed_result[-1, ])
colnames(corrected_transposed_result) <- new_colname
row_names <- rownames(transposed_result)
row_names <- row_names[-1]
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- row_names
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction(raw_data, array_type = "huprot", format = "wide")
#' \dontrun{
#' # Assuming 'raw_data' is an RGList object obtained from read.gpr()
#' Meaning run read.gpr first!
#'
#' # Extract data in long format for chambered arrays
#' long_data <- extraction(data = raw_data, array_type = "chambered", format = "long")
#'
#' # Extract data in wide format for huprot arrays
#' wide_data <- extraction(data = raw_data, array_type = "huprot", format = "wide")
#' }
extraction <- function(data, array_type, format = "wide", channel = "R") {
proteins <- data$genes
files <- data$targets
values <- data[[channel]]
array_count <- ncol(values)
combined_list <- vector("list", array_count)
for (i in 1:array_count) {
df <- as.data.frame(proteins)
df$array <- files[[1]][i]
df$value <- values[, i]
combined_list[[i]] <- df
}
df_out <- do.call(rbind, combined_list)
# Validate array_type parameter
if (!(array_type %in% c("chambered", "segmented", "huprot"))) {
stop("Invalid array_type. Please specify 'chambered', 'segmented', or 'huprot'.")
}
if (format == "long" & array_type != "huprot") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
output <- long_result
message("Data calculated/arranged for chambered/segmented arrays")
message("Long data created based on format input (user defined: long)")
} else if (format == "long" & array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
message("Data calculated/arranged for huprot arrays")
message("Long data created based on format input (user defined: long)")
output <- long_result
} else if (format == "wide") {
if (array_type == "chambered" || array_type == "segmented") {
mid <- df_out %>%
dplyr::group_by(array, Block, Name, ID) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
ungroup()
long_result <- mid %>%
group_by(array, Block, Name) %>%
summarise(Mvalue = if(n() > 5) Mvalue = mean(Mvalue, na.rm = T) else Mvalue) %>%
mutate(Name = make.unique(as.character(Name), sep = ".")) %>%
ungroup()
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for chambered/segmented arrays")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- paste0(array, "Block", transposed_result[2,])
corrected_transposed_result <- transposed_result[-c(1, 2), ]
colnames(corrected_transposed_result) <- new_colname
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- rownames(corrected_transposed_result)
} else if (array_type == "huprot") {
long_result <- df_out %>%
dplyr::group_by(array, Name, Block, Column) %>%
dplyr::summarise(Mvalue = mean(value, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::select(-Block, -Column) %>%
dplyr::group_by(array, Name) %>%
dplyr::summarise(Mvalue = if (n() >= 8) mean(Mvalue, na.rm = TRUE) else Mvalue) %>%
dplyr::mutate(Name = make.unique(as.character(Name), sep = "."))
wide_result <- tidyr::pivot_wider(long_result, names_from = Name, values_from = Mvalue)
message("Data calculated/arranged for huprot arrays. Duplicate protein names appended with .n --creating dataframe...")
transposed_result <- as.data.frame(t(wide_result))
file_names <- as.character(transposed_result[1, ])
array <- paste0("Arr", sapply(basename(file_names), function(x) gsub("[^0-9]", "", x)))
new_colname <- array
corrected_transposed_result <- as.data.frame(transposed_result[-1, ])
colnames(corrected_transposed_result) <- new_colname
row_names <- rownames(transposed_result)
row_names <- row_names[-1]
numeric_df <- as.data.frame(lapply(corrected_transposed_result, as.numeric))
numeric_df <- as.data.frame(apply(numeric_df, 2, function(x) round(x, 2)))
rownames(numeric_df) <- row_names
} else {
stop("Please define array type. Supports 'chambered', 'segmented', or 'huprot'.")
}
if (nrow(numeric_df) == 0) {
warning("The resulting data frame is empty after processing.")
}
colnames(numeric_df) <- gsub("\\.", "0", colnames(numeric_df))
output <- numeric_df
message("Wide data created based on format input (user defined: wide)")
}
return(output)
}
wide_df2 <- extraction(raw_data, array_type = "huprot", format = "wide")
View(wide_df2)
wide_df2 <- extraction(raw_data, array_type = "huprot", format = "wide", channel = "G")
View(wide_df2)
View(wide_df)
View(wide_df2)
View(wide_df2)
View(wide_df)
View(wide_df2)
View(wide_df)
library(roxygen2)
library(devtools)
check()
check()
build()
library(arrayrank)
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
wide_df <- extraction(raw_data, array_type = "chambered", format = "wide")
q995 <- quantile(unlist(wide_df), 0.995)
q005 <- quantile(unlist(wide_df), 0.005)
q005 <- quantile(unlist(wide_df), 0.01)
q005 <- quantile(unlist(wide_df), 0.001)
median <- median(wide_df)
View(wide_df)
median <- median(unlist(wide_df))
wide_df[wide_df < 0] <- 0.1
View(wide_df)
median <- median(unlist(wide_df))
features_wins[features_wins > q995] <- q995
q005 <- quantile(unlist(wide_df), 0.001)
q005 <- quantile(unlist(wide_df), 0.05)
wide_df <- extraction(raw_data, array_type = "chambered", format = "wide")
q001 <- quantile(unlist(wide_df), 0.01)
median <- median(unlist(wide_df))
sd <- sd(unlist(wide_df))
sd <- sem(unlist(wide_df))
sem <- sd / sqrt(length(unlist(wide_df)))
library(arrayrank)
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
wide_df2 <- extraction(raw_data, array_type = "huprot", format = "wide", channel = "G")
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
View(wide_df)
View(wide_df2)
library(arrayrank)
library(tibble)
library(scales)
library(gridExtra)
library(ggplot2)
library(cowplot)
library(dplyr)
library(tidyr)
# 1. collect gpr data and make dataset
raw_data <- read.gpr(bgcorrect = T, fdata = "median")
wide_df <- extraction(raw_data, array_type = "huprot", format = "wide")
# 2. data correction
corr_df <- replace.low(wide_df, offset = 10)
norm_df <- multinorm(corr_df, method= "quantile")
##################
# read key file
key <- readxl::read_xlsx(choose.files())
# key-matching function
match.key <- function(key, data){
trans_data <- as.data.frame(t(data))
trans_data$Array <- rownames(trans_data)
trans_data <- trans_data[, c("Array", setdiff(names(trans_data), "Array"))]
merged_df <- as.data.frame(t(merge(key, trans_data, by = "Array")))
colnames(merged_df) <- merged_df["Array",]
merged_df <- merged_df[-1,]
return(merged_df)
}
# write output with keymatching
write.data.complete <- function(key, wide_df, corr_df, norm_df, file_name = "Data_complete.xlsx") {
raw_df_metadata <- match.key(key, wide_df)
corr_df_metadata <- match.key(key, corr_df)
norm_df_metadata <- match.key(key, norm_df)
stored_raw <- store.df(raw_df_metadata)
stored_offset_corr <- store.df(corr_df_metadata)
store_df <- store.df(norm_df_metadata)
stored_data <- list(
"Raw" = stored_raw,
"Offset" = stored_offset_corr,
"Qnorm" = store_df
)
# Write to Excel file
writexl::write_xlsx(stored_data, file_name)
return(stored_data)
}
stored_data <- write.data.complete(key, wide_df, corr_df, norm_df, file_name = "Data_complete_Malena_etal.xlsx")
View(key)
View(norm_df)
